
# apply sapply lapply


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(flair)
library(tidyverse)
library(learnr)
```

## Introduction

The apply family of functions are one of the most commonly used classes and are used to manipulate data (in the form of matrices/arrays/dataframes/lists etc) repetitively. They are generally used to run a function on multiple chunks of data of an object.

If you have programmed before, the functionality of apply functions can be thought of as a 'for loop' but they are considered more efficient. 
In this lesson we will be covering apply, lapply and mapply. However, there is a huge variety of apply functions available and while they work for different kinds of data, all of these have at least two common arguments- an object and a function(which can be either user-defined or built in) and we can "apply" the latter to the former. We will get into the details of the arguments how to use thme later. 



In this lesson, you will learn how to:
- Use apply, mapply and lapply (functions from the apply family)
- Use appropriate versions of the apply family of functions for the correct use cases


### Prereqs 
- Basic understanding of lists, vectors, arrays, matrices, and data frames


### Function Arguments

Let's first take a look at what the r documentation has as the arguments for these functions:

 - apply(X, MARGIN, FUN, ..., simplify = TRUE)

 - lapply(X, FUN, ...)
 
 - sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

Where:


| Argument      | Details                                                                                         |
|---------------|-------------------------------------------------------------------------------------------------|
| X             | The object to which we want to apply the function (can be array/matrix/list/vector/data frame)  |
| MARGIN        | A vector to specify how the function is applied(1 for along row/2 for column)                   |
| FUN           | The function(in-built or user defined) to be applied repeatedly to the elements of X            |
| ...           | Optional arguments to FUN                                                                       |
| simplify      | Logical to pick simplified results (a matrix or vector when possible)                           |
| USE.NAMES     | Logical; set to TRUE X is character and want X as names for the result                          |



At first look these functions might all seem the same.
---MEME----

Now let's dive deeper into their differences to understand better.

## Apply
Let's start with apply which is the most basic apply function (can be thought of as a ). It operates primarily on arrays and matrices and can occasionally with data frames but with restrictions(the data frame must have objects of similar types that the function can operate on).  
This is the only function(out of the ones covered in this lesson) that requires margins to be specified. For eg. for a matrix, 1 would mean the function would be applied along the rows, 2 would be columns, and c(1,2) would be both rows and columns. 


## Lapply
This is another member of the apply family of functions and has two main differences compared to apply-  
1) it always returns a list the same length as the input list
2) it does not require margin specification as it only applies the function to columns
Lapply operates on list, data frames, vectors.

## Sapply
The final apply function covered in this lesson is sapply. The documentation page for r defines as sapply is a user-friendly version of lapply. 
What this means is, sapply is a wrapper of lapply and the only difference is that it simplifies the output(when possible) and returns a vector instead of list. 
Just like lapply, sapply also operates on lists, data frames and vectors and does not need margin specification and just like in apply, we can use simplify = TRUE to simplify the results. 

Note- sapply(x, f, simplify = FALSE, USE.NAMES = FALSE) would be the same as lapply(x, f)

## Summary of differences table
To summarize the differences between these functions, we can use this table:
\

| Function | Operates on                 | Returns                             | Margins to specify(yes/no) |
|----------|-----------------------------|-------------------------------------|----------------------------|
| Apply    | arrays and matrices         | a vector or array or list of values | Yes                        |
| Lapply   | lists, data frames, vectors | a list                              | No                         |
| Sapply   | lists, data frames, vectors | a vector                            | No                         |


### Examples

#### Example 1
We will first work with the popular mtcars data set to understand how these functions work. Let's take a quick look at it 
```{r}
data <- mtcars
head(mtcars)
```
Let's subset this dataset to fit our needs better and call it cars. 
```{r}
cars <- data[c(4, 6 )]
```
We can now find the means of all columns 

```{r}
apply(cars, 2, mean)
```

We can also find the column quantiles using the quantile function

```{r}
apply(cars, 2, quantile, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))
```

While it is not too relevant in this context, we can also compute the sum of rows
```{r}
apply(cars, 1, sum)
```

#### Example 2

As mentioned before, we can also use a user-defined function with apply. Let's first generate a random matrix.
```{r}
mat <- matrix(rep(seq(5), 4), ncol = 5)
```

We can apply a user defined function inside the function to sum along the rows and add 5 to each element.
```{r}
apply(mat, 1, function(x) sum(x) + 5)
```
Or we can use the user-defined function as an argument:
```{r}
func <- function(x){
  return (sum(x)+5)
}
apply(mat, 1, func)
```



#### Example 3
We can create a random list to test out the lapply and sapply functions.
```{r}

list_i <- list(i1 = 1:10, 
             i2 = rnorm(20), 
             i3 = rnorm(20, 1), 
             i4 = rnorm(100, 5))
list_i

lapply(list_i, mean)
sapply(list_i, mean)

```
As you can see, lapply returns a more complicated vector output and sapply returns the same output in a list.


## Exercises 

### Question 1

```{r letter-a, echo=FALSE}
question("What is the output of the lapply function?",
  answer("a list"),
  answer("an array"),
  answer("a vector", correct = TRUE)
)
```

 
### Question 2

 a) Use the numerical columns(columns 1-4) of the `iris` dataset to compute the minimum value of each column using apply, lapply and sapply. And store the outputs.

```{r q2_a, exercise.eval = TRUE, exercise = TRUE}
head(iris)
```

```{r q2_a-solution}
ap <- apply(iris[,-5], MARGIN = 2,  FUN = min) 
l_ap <- lapply(iris[,-5], FUN = min) 
s_ap <- sapply(iris[,-5], FUN = min)
```
\
  b) Add the three outputs from above to a list called "list_output".
```{r q2_b, exercise.eval = TRUE, exercise = TRUE}

```

```{r q2_b-solution}
list_output <- list(ap, l_ap, s_ap )
```
 \
  c) Use an appropriate apply function to find the type of each element of list_output (using the type of function) 
```{r q2_c, exercise.eval = TRUE, exercise = TRUE}

```

```{r q2_c-solution}
sapply(FUN = typeof, X = list_output) 
```


## Some extra notes

1) If you are deciding between using for loops or apply functions, always pick apply functions are they are slightly faster and require fewer lines of code. That also make the code easier to read and understand.
---HIGHWAY MEME-----

2) Apply functions are capable of a lot of things including the option  to ignore the NA values (if there are any) by using na.rm inside the apply function. Among several other cool things, we can also use the apply function to generate plots for the objects like this:
```{r}
head(iris)
apply(iris[,-5], 2, boxplot) #ignoring the Species column
```
Here, we are generating a box plot for all numerical columns of the iris data set. 
--OPRAH MEME---

3) Using these functions can often be tricky. If you are ever struggling to decide between these functions and want results simplified, the easiest option would be sapply. On the off-chance that you don't want simplified results, use lapply.
--BUTTON MEME----

## Common mistakes and errors


## Next steps
- To know more about these functions, a useful additional resource is- https://www.analyticsvidhya.com/blog/2021/02/the-ultimate-swiss-army-knife-of-apply-family-in-r/
- You can explore other functions of the apply family like tapply, vapply, mapply
- You can also explore "apply-like" functions such as colSums/rowSums/colMeans/rowMeans etc

## References

- [r documentation] (https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/apply).
